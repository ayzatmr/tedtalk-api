package com.io.tedtalks.repository;

import static com.io.tedtalks.jooq.tables.TedTalks.TED_TALKS;

import com.io.tedtalks.dto.PagedResponse;
import com.io.tedtalks.jooq.tables.pojos.TedTalks;
import com.io.tedtalks.model.TedTalk;
import java.util.List;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.SortField;
import org.jooq.impl.DSL;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Repository;

/**
 * Repository interface for querying and persisting {@code TedTalkEntity} objects. This interface
 * extends the {@code JpaRepository} to provide basic CRUD operations and additional query methods
 * for filtering TED Talks based on specific criteria.
 */
@Repository
@RequiredArgsConstructor
public class TedTalkRepository {

  private final DSLContext dsl;

  /**
   * Saves a TedTalk entity to the database. If the given TedTalk does not have an ID, a new
   * record is inserted and the generated TedTalk is returned. If the given TedTalk has an ID,
   * the existing record is updated with the new values and the original TedTalk is returned.
   *
   * @param tedTalk the TedTalk entity to be saved; must not be null
   * @return the saved TedTalk entity with any autogenerated fields populated, or null if an error occurs during insertion
   */
  public TedTalk save(TedTalk tedTalk) {
    if (tedTalk.getId() == null) {
      var record =
          dsl.insertInto(TED_TALKS)
              .set(TED_TALKS.TITLE, tedTalk.getTitle())
              .set(TED_TALKS.AUTHOR, tedTalk.getAuthor())
              .set(TED_TALKS.YEAR_VALUE, tedTalk.getYearValue())
              .set(TED_TALKS.MONTH_VALUE, tedTalk.getMonthValue())
              .set(TED_TALKS.VIEWS, tedTalk.getViews())
              .set(TED_TALKS.LIKES, tedTalk.getLikes())
              .set(TED_TALKS.LINK, tedTalk.getLink())
              .returning()
              .fetchOne();

      return record != null ? new TedTalk(record.into(TedTalks.class)) : null;
    } else {
      dsl.update(TED_TALKS)
          .set(TED_TALKS.TITLE, tedTalk.getTitle())
          .set(TED_TALKS.AUTHOR, tedTalk.getAuthor())
          .set(TED_TALKS.YEAR_VALUE, tedTalk.getYearValue())
          .set(TED_TALKS.MONTH_VALUE, tedTalk.getMonthValue())
          .set(TED_TALKS.VIEWS, tedTalk.getViews())
          .set(TED_TALKS.LIKES, tedTalk.getLikes())
          .set(TED_TALKS.LINK, tedTalk.getLink())
          .where(TED_TALKS.ID.eq(tedTalk.getId()))
          .execute();

      return tedTalk;
    }
  }

  public List<TedTalk> saveAll(List<TedTalk> tedTalks) {
    if (tedTalks.isEmpty()) {
      return tedTalks;
    }

    var batch = dsl.batch(
        tedTalks.stream()
            .map(
                tedTalk ->
                    dsl.insertInto(TED_TALKS)
                        .set(TED_TALKS.TITLE, tedTalk.getTitle())
                        .set(TED_TALKS.AUTHOR, tedTalk.getAuthor())
                        .set(TED_TALKS.YEAR_VALUE, tedTalk.getYearValue())
                        .set(TED_TALKS.MONTH_VALUE, tedTalk.getMonthValue())
                        .set(TED_TALKS.VIEWS, tedTalk.getViews())
                        .set(TED_TALKS.LIKES, tedTalk.getLikes())
                        .set(TED_TALKS.LINK, tedTalk.getLink()))
            .toList());

    batch.execute();
    return tedTalks;
  }

  public Optional<TedTalk> findById(Long id) {
    return dsl.selectFrom(TED_TALKS).where(TED_TALKS.ID.eq(id)).fetchOptional()
        .map(r -> new TedTalk(r.into(TedTalks.class)));
  }

  public void deleteAll() {
    dsl.deleteFrom(TED_TALKS).execute();
  }

  public boolean existsById(Long id) {
    return dsl.fetchExists(dsl.selectFrom(TED_TALKS).where(TED_TALKS.ID.eq(id)));
  }

  public void deleteById(Long id) {
    dsl.deleteFrom(TED_TALKS).where(TED_TALKS.ID.eq(id)).execute();
  }

  public PagedResponse<TedTalk> findByFilters(
      String author, Integer year, String keyword, Pageable pageable) {

    Condition condition = DSL.trueCondition();

    if (author != null && !author.isBlank()) {
      condition = condition.and(DSL.lower(TED_TALKS.AUTHOR).startsWith(author.toLowerCase()));
    }

    if (year != null) {
      condition = condition.and(TED_TALKS.YEAR_VALUE.eq(year));
    }

    if (keyword != null && !keyword.isBlank()) {
      String lowerKeyword = keyword.toLowerCase();
      condition =
          condition.and(
              DSL.lower(TED_TALKS.TITLE)
                  .startsWith(lowerKeyword)
                  .or(DSL.lower(TED_TALKS.AUTHOR).startsWith(lowerKeyword)));
    }

    Long total = dsl.selectCount().from(TED_TALKS).where(condition).fetchOne(0, Long.class);
    if (total == null) {
      total = 0L;
    }

    List<TedTalk> content =
        dsl.selectFrom(TED_TALKS)
            .where(condition)
            .orderBy(toSortFields(pageable.getSort()))
            .limit(pageable.getPageSize())
            .offset(pageable.getOffset())
            .fetch()
            .map(r -> new TedTalk(r.into(TedTalks.class)));

    return new PagedResponse<>(
        content,
        pageable.getPageNumber(),
        pageable.getPageSize(),
        total,
        (int) Math.ceil((double) total / pageable.getPageSize()));
  }

  private List<SortField<?>> toSortFields(Sort sort) {
    return sort.stream()
        .map(
            order -> {
              var field = TED_TALKS.field(order.getProperty().toUpperCase());
              return order.isAscending() ? field.asc() : field.desc();
            })
        .toList();
  }
}
